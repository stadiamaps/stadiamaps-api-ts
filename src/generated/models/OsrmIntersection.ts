/* tslint:disable */
/* eslint-disable */
/**
 * Stadia Maps Geospatial APIs
 * The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications.
 *
 * The version of the OpenAPI document: 9.2.1
 * Contact: support@stadiamaps.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from "../runtime";
import type { OsrmLane } from "./OsrmLane";
import {
  OsrmLaneFromJSON,
  OsrmLaneFromJSONTyped,
  OsrmLaneToJSON,
  OsrmLaneToJSONTyped,
} from "./OsrmLane";

/**
 * Detailed information about intersections that the route traverses. For every step, the first intersection is at the location of the maneuver. Additional intersections will be provided for every road or path traversed until the next step.
 * @export
 * @interface OsrmIntersection
 */
export interface OsrmIntersection {
  /**
   * A (longitude, latitude) coordinate pair.
   * @type {Array<number>}
   * @memberof OsrmIntersection
   */
  location: Array<number>;
  /**
   * A list of bearing values that are available for travel through the intersection.
   * @type {Array<number>}
   * @memberof OsrmIntersection
   */
  bearings: Array<number>;
  /**
   *
   * @type {Array<string>}
   * @memberof OsrmIntersection
   */
  classes?: Array<OsrmIntersectionClassesEnum>;
  /**
   * A list of entry flags, which map 1:1 to the bearings. A value of true indicates that the respective road could be entered on a valid route. False indicates that the turn onto the respective road would violate a restriction.
   * @type {Array<boolean>}
   * @memberof OsrmIntersection
   */
  entry: Array<boolean>;
  /**
   * An index into bearings/entry array. Used to calculate the bearing just before the turn. Namely, the clockwise angle from true north to the direction of travel immediately before the maneuver/passing the intersection. Bearings are given relative to the intersection. To get the bearing in the direction of driving, the bearing has to be rotated by a value of 180. The value is not supplied for depart maneuvers.
   * @type {number}
   * @memberof OsrmIntersection
   */
  _in?: number;
  /**
   * An index into bearings/entry array. Used to calculate the bearing just after the turn. Namely, the clockwise angle from true north to the direction of travel immediately after the maneuver/passing the intersection. This is not supplied for arrive maneuvers.
   * @type {number}
   * @memberof OsrmIntersection
   */
  out?: number;
  /**
   * Available turn lanes at the intersection. May be omitted if no lane information is available for the intersection.
   * @type {Array<OsrmLane>}
   * @memberof OsrmIntersection
   */
  lanes?: Array<OsrmLane>;
  /**
   * The index into the admin boundaries list on the route leg.
   * @type {number}
   * @memberof OsrmIntersection
   */
  adminIndex?: number;
  /**
   * The estimated duration, in seconds, to traverse the intersection.
   * @type {number}
   * @memberof OsrmIntersection
   */
  duration?: number;
  /**
   * The estimated duration, in seconds, to complete the turn.
   * @type {number}
   * @memberof OsrmIntersection
   */
  turnDuration?: number;
  /**
   *
   * @type {number}
   * @memberof OsrmIntersection
   */
  turnWeight?: number;
  /**
   * The index of the intersection in the leg geometry.
   * @type {number}
   * @memberof OsrmIntersection
   */
  geometryIndex?: number;
  /**
   *
   * @type {number}
   * @memberof OsrmIntersection
   */
  weight?: number;
}

/**
 * @export
 */
export const OsrmIntersectionClassesEnum = {
  Toll: "toll",
  Ferry: "ferry",
  Restricted: "restricted",
  Motorway: "motorway",
  Tunnel: "tunnel",
} as const;
export type OsrmIntersectionClassesEnum =
  (typeof OsrmIntersectionClassesEnum)[keyof typeof OsrmIntersectionClassesEnum];

/**
 * Check if a given object implements the OsrmIntersection interface.
 */
export function instanceOfOsrmIntersection(
  value: object,
): value is OsrmIntersection {
  if (!("location" in value) || value["location"] === undefined) return false;
  if (!("bearings" in value) || value["bearings"] === undefined) return false;
  if (!("entry" in value) || value["entry"] === undefined) return false;
  return true;
}

export function OsrmIntersectionFromJSON(json: any): OsrmIntersection {
  return OsrmIntersectionFromJSONTyped(json, false);
}

export function OsrmIntersectionFromJSONTyped(
  json: any,
  ignoreDiscriminator: boolean,
): OsrmIntersection {
  if (json == null) {
    return json;
  }
  return {
    location: json["location"],
    bearings: json["bearings"],
    classes: json["classes"] == null ? undefined : json["classes"],
    entry: json["entry"],
    _in: json["in"] == null ? undefined : json["in"],
    out: json["out"] == null ? undefined : json["out"],
    lanes:
      json["lanes"] == null
        ? undefined
        : (json["lanes"] as Array<any>).map(OsrmLaneFromJSON),
    adminIndex: json["admin_index"] == null ? undefined : json["admin_index"],
    duration: json["duration"] == null ? undefined : json["duration"],
    turnDuration:
      json["turn_duration"] == null ? undefined : json["turn_duration"],
    turnWeight: json["turn_weight"] == null ? undefined : json["turn_weight"],
    geometryIndex:
      json["geometry_index"] == null ? undefined : json["geometry_index"],
    weight: json["weight"] == null ? undefined : json["weight"],
  };
}

export function OsrmIntersectionToJSON(json: any): OsrmIntersection {
  return OsrmIntersectionToJSONTyped(json, false);
}

export function OsrmIntersectionToJSONTyped(
  value?: OsrmIntersection | null,
  ignoreDiscriminator: boolean = false,
): any {
  if (value == null) {
    return value;
  }

  return {
    location: value["location"],
    bearings: value["bearings"],
    classes: value["classes"],
    entry: value["entry"],
    in: value["_in"],
    out: value["out"],
    lanes:
      value["lanes"] == null
        ? undefined
        : (value["lanes"] as Array<any>).map(OsrmLaneToJSON),
    admin_index: value["adminIndex"],
    duration: value["duration"],
    turn_duration: value["turnDuration"],
    turn_weight: value["turnWeight"],
    geometry_index: value["geometryIndex"],
    weight: value["weight"],
  };
}
